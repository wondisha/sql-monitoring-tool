SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- Error logging table creation (idempotent)
IF NOT EXISTS (SELECT 1 FROM sys.tables WHERE name = 'SQLBestPracticeMonitoringErrors')
BEGIN
    CREATE TABLE SQLBestPracticeMonitoringErrors (
        InstanceID INT,
        DBID INT,
        DatabaseName SYSNAME,
        BestPracticeName NVARCHAR(100),
        ErrorMessage NVARCHAR(MAX),
        ErrorLine INT,
        LogTime DATETIME
    );
END
GO

ALTER PROCEDURE [dbo].[usp_CheckSQLBestPractices]
AS
BEGIN
    SET NOCOUNT ON;

    -- Debug log table
    DECLARE @DebugLog TABLE (LogMessage NVARCHAR(MAX), LogTime DATETIME);

    -- Instance-level variables
    DECLARE @InstanceID INT, @InstanceName NVARCHAR(100);
    DECLARE @RecommendedMaxDOP INT, @LogicalProcessorsPerNUMA INT, @NUMANodeCount INT, @TotalLogicalProcessors INT, @CurrentMaxDOP INT;
    DECLARE @CurrentCostThreshold INT, @RecommendedCostThreshold INT = 25;
    DECLARE @MaxServerMemory BIGINT, @MinServerMemory BIGINT, @TotalPhysicalMemory BIGINT;
    DECLARE @TempdbFileCount INT, @TempdbRecommendedFiles INT;
    DECLARE @LatestCompatLevel INT;
    DECLARE @DBID INT, @DBName NVARCHAR(128);

    -- Log start of execution
    INSERT INTO @DebugLog (LogMessage, LogTime) VALUES ('Starting SQL Best Practices Check', GETDATE());

    -- Instance Cursor
    DECLARE instance_cursor CURSOR LOCAL FAST_FORWARD FOR
    SELECT InstanceID, Instance FROM Instances;

    OPEN instance_cursor;
    FETCH NEXT FROM instance_cursor INTO @InstanceID, @InstanceName;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        -- Gather instance-level info
        BEGIN TRY
            -- Calculate recommended MaxDOP
            SELECT @NUMANodeCount = COUNT(DISTINCT node_id)
            FROM sys.dm_os_nodes
            WHERE node_state_desc = 'ONLINE' AND node_id < 64;

            SELECT @TotalLogicalProcessors = cpu_count
            FROM sys.dm_os_sys_info;

            SET @LogicalProcessorsPerNUMA = CASE WHEN @NUMANodeCount > 0 THEN @TotalLogicalProcessors / @NUMANodeCount ELSE @TotalLogicalProcessors END;
            SET @RecommendedMaxDOP = CASE WHEN @LogicalProcessorsPerNUMA <= 8 THEN @LogicalProcessorsPerNUMA ELSE 8 END;

            SELECT @CurrentMaxDOP = CAST(value_in_use AS INT)
            FROM sys.configurations
            WHERE Name = 'max degree of parallelism';

            SELECT @CurrentCostThreshold = CAST(value_in_use AS INT)
            FROM sys.configurations
            WHERE name = 'cost threshold for parallelism';

            SELECT @MaxServerMemory = CAST(value_in_use AS BIGINT)
            FROM sys.configurations
            WHERE name = 'max server memory (MB)';

            SELECT @MinServerMemory = CAST(value_in_use AS BIGINT)
            FROM sys.configurations
            WHERE name = 'min server memory (MB)';

            SELECT @TotalPhysicalMemory = total_physical_memory_kb / 1024
            FROM sys.dm_os_sys_memory;

            SELECT @TempdbFileCount = COUNT(*)
            FROM sys.master_files
            WHERE database_id = DB_ID('tempdb') AND type = 0;

            SET @TempdbRecommendedFiles = CASE WHEN @TotalLogicalProcessors <= 8 THEN @TotalLogicalProcessors ELSE 8 END;

            SELECT @LatestCompatLevel =
                CASE
                    WHEN SERVERPROPERTY('ProductMajorVersion') = 16 THEN 160
                    WHEN SERVERPROPERTY('ProductMajorVersion') = 15 THEN 150
                    WHEN SERVERPROPERTY('ProductMajorVersion') = 14 THEN 140
                    WHEN SERVERPROPERTY('ProductMajorVersion') = 13 THEN 130
                    ELSE 120
                END;

            -- Instance-Level Checks

            -- MaxDOP
            UPDATE SQLBestPracticeMonitoring
            SET Status = 'Resolved', 
                CurrentValue = CAST(@CurrentMaxDOP AS NVARCHAR(255)), 
                Notes = 'MaxDOP is set as recommended.', 
                ResolvedDate = GETDATE()
            WHERE InstanceID = @InstanceID
              AND DBID = 0
              AND BestPracticeName = 'MaxDOP'
              AND Status = 'Unresolved'
              AND EXISTS (
                  SELECT 1 FROM sys.configurations 
                  WHERE Name = 'max degree of parallelism' 
                  AND CAST(value_in_use AS INT) = @RecommendedMaxDOP
              );

            INSERT INTO SQLBestPracticeMonitoring (InstanceID, DBID, InstanceName, DatabaseName, BestPracticeName, CurrentValue, RecommendedValue, Status, Notes)
            SELECT @InstanceID, 0, @InstanceName, 'InstanceLevel', 'MaxDOP', 
                   CAST(@CurrentMaxDOP AS NVARCHAR(255)), 
                   CAST(@RecommendedMaxDOP AS NVARCHAR(255)), 
                   'Unresolved',
                   'MaxDOP should be set to ' + CAST(@RecommendedMaxDOP AS NVARCHAR(10)) + ' based on server configuration.'
            WHERE NOT EXISTS (
                SELECT 1 FROM sys.configurations 
                WHERE Name = 'max degree of parallelism' 
                AND CAST(value_in_use AS INT) = @RecommendedMaxDOP
            )
            AND NOT EXISTS (
                SELECT 1 FROM SQLBestPracticeMonitoring
                WHERE InstanceID = @InstanceID AND DBID = 0 AND BestPracticeName = 'MaxDOP' AND Status = 'Unresolved'
            );

            -- Cost Threshold for Parallelism
            UPDATE SQLBestPracticeMonitoring
            SET Status = 'Resolved', 
                CurrentValue = CAST(@CurrentCostThreshold AS NVARCHAR(255)), 
                Notes = 'Cost threshold for parallelism is appropriately configured.', 
                ResolvedDate = GETDATE()
            WHERE InstanceID = @InstanceID
              AND DBID = 0
              AND BestPracticeName = 'CostThresholdParallelism'
              AND Status = 'Unresolved'
              AND EXISTS (
                  SELECT 1 FROM sys.configurations 
                  WHERE name = 'cost threshold for parallelism' 
                  AND CAST(value_in_use AS INT) >= @RecommendedCostThreshold
              );

            INSERT INTO SQLBestPracticeMonitoring (InstanceID, DBID, InstanceName, DatabaseName, BestPracticeName, CurrentValue, RecommendedValue, Status, Notes)
            SELECT @InstanceID, 0, @InstanceName, 'InstanceLevel', 'CostThresholdParallelism', 
                   CAST(@CurrentCostThreshold AS NVARCHAR(255)), 
                   CAST(@RecommendedCostThreshold AS NVARCHAR(255)), 
                   'Unresolved',
                   'Cost threshold for parallelism should be at least ' + CAST(@RecommendedCostThreshold AS NVARCHAR(10)) + ' for better performance.'
            WHERE NOT EXISTS (
                SELECT 1 FROM sys.configurations 
                WHERE name = 'cost threshold for parallelism' 
                AND CAST(value_in_use AS INT) >= @RecommendedCostThreshold
            )
            AND NOT EXISTS (
                SELECT 1 FROM SQLBestPracticeMonitoring
                WHERE InstanceID = @InstanceID AND DBID = 0 AND BestPracticeName = 'CostThresholdParallelism' AND Status = 'Unresolved'
            );

            -- Max Server Memory
            UPDATE SQLBestPracticeMonitoring
            SET Status = 'Resolved', 
                CurrentValue = CAST(@MaxServerMemory AS NVARCHAR(255)) + ' MB', 
                Notes = 'Max server memory is properly configured.', 
                ResolvedDate = GETDATE()
            WHERE InstanceID = @InstanceID
              AND DBID = 0
              AND BestPracticeName = 'MaxServerMemory'
              AND Status = 'Unresolved'
              AND EXISTS (
                  SELECT 1 FROM sys.configurations 
                  WHERE name = 'max server memory (MB)' 
                  AND CAST(value_in_use AS BIGINT) != 2147483647 
                  AND CAST(value_in_use AS BIGINT) < (@TotalPhysicalMemory * 0.9)
              );

            INSERT INTO SQLBestPracticeMonitoring (InstanceID, DBID, InstanceName, DatabaseName, BestPracticeName, CurrentValue, RecommendedValue, Status, Notes)
            SELECT @InstanceID, 0, @InstanceName, 'InstanceLevel', 'MaxServerMemory',
                   CASE WHEN @MaxServerMemory = 2147483647 THEN 'Unlimited (Default)' ELSE CAST(@MaxServerMemory AS NVARCHAR(255)) + ' MB' END,
                   CAST(CAST(@TotalPhysicalMemory * 0.8 AS INT) AS NVARCHAR(255)) + ' MB', 
                   'Unresolved',
                   'Max server memory should be configured to leave memory for OS. Recommended: ' + CAST(CAST(@TotalPhysicalMemory * 0.8 AS INT) AS NVARCHAR(10)) + ' MB'
            WHERE NOT EXISTS (
                SELECT 1 FROM sys.configurations 
                WHERE name = 'max server memory (MB)' 
                AND CAST(value_in_use AS BIGINT) != 2147483647 
                AND CAST(value_in_use AS BIGINT) < (@TotalPhysicalMemory * 0.9)
            )
            AND NOT EXISTS (
                SELECT 1 FROM SQLBestPracticeMonitoring
                WHERE InstanceID = @InstanceID AND DBID = 0 AND BestPracticeName = 'MaxServerMemory' AND Status = 'Unresolved'
            );

            -- Tempdb Configuration
            UPDATE SQLBestPracticeMonitoring
            SET Status = 'Resolved', 
                CurrentValue = CAST(@TempdbFileCount AS NVARCHAR(255)) + ' files', 
                Notes = 'Tempdb has optimal number of data files.', 
                ResolvedDate = GETDATE()
            WHERE InstanceID = @InstanceID
              AND DBID = 0
              AND BestPracticeName = 'TempdbFileCount'
              AND Status = 'Unresolved'
              AND @TempdbFileCount = @TempdbRecommendedFiles;

            INSERT INTO SQLBestPracticeMonitoring (InstanceID, DBID, InstanceName, DatabaseName, BestPracticeName, CurrentValue, RecommendedValue, Status, Notes)
            SELECT @InstanceID, 0, @InstanceName, 'InstanceLevel', 'TempdbFileCount', 
                   CAST(@TempdbFileCount AS NVARCHAR(255)) + ' files', 
                   CAST(@TempdbRecommendedFiles AS NVARCHAR(255)) + ' files', 
                   'Unresolved',
                   'Tempdb should have ' + CAST(@TempdbRecommendedFiles AS NVARCHAR(10)) + ' data files (equal to CPU cores, max 8) for optimal performance.'
            WHERE @TempdbFileCount != @TempdbRecommendedFiles
              AND NOT EXISTS (
                  SELECT 1 FROM SQLBestPracticeMonitoring
                  WHERE InstanceID = @InstanceID AND DBID = 0 AND BestPracticeName = 'TempdbFileCount' AND Status = 'Unresolved'
              );

        END TRY
        BEGIN CATCH
            INSERT INTO SQLBestPracticeMonitoringErrors (
                InstanceID, DBID, DatabaseName, BestPracticeName,
                ErrorMessage, ErrorLine, LogTime
            )
            VALUES (
                ISNULL(@InstanceID, -1),
                0,
                ISNULL(@InstanceName, 'Unknown'),
                'InstanceLevel',
                ERROR_MESSAGE(),
                ERROR_LINE(),
                GETDATE()
            );

            INSERT INTO @DebugLog (LogMessage, LogTime)
            VALUES ('Instance-level Error: ' + ERROR_MESSAGE(), GETDATE());
        END CATCH

        -- Database-level checks for this instance
        DECLARE db_cursor CURSOR LOCAL FAST_FORWARD FOR
        SELECT DBID, Name
        FROM DBInfo
        WHERE InstanceID = @InstanceID
          AND Name NOT IN ('master', 'model', 'msdb', 'tempdb');

        OPEN db_cursor;
        FETCH NEXT FROM db_cursor INTO @DBID, @DBName;

        WHILE @@FETCH_STATUS = 0
        BEGIN
            BEGIN TRY
                -- Page Verify Check
                UPDATE SQLBestPracticeMonitoring
                SET Status = 'Resolved', 
                    CurrentValue = 'CHECKSUM', 
                    Notes = 'Page Verify is set to CHECKSUM.', 
                    ResolvedDate = GETDATE()
                FROM SQLBestPracticeMonitoring bpm
                JOIN sys.databases d ON bpm.DBID = d.database_id
                WHERE bpm.InstanceID = @InstanceID
                  AND bpm.DBID = @DBID
                  AND bpm.BestPracticeName = 'PageVerify'
                  AND d.page_verify_option_desc = 'CHECKSUM'
                  AND bpm.Status = 'Unresolved';

                INSERT INTO SQLBestPracticeMonitoring (InstanceID, DBID, InstanceName, DatabaseName, BestPracticeName, CurrentValue, RecommendedValue, Status, Notes)
                SELECT @InstanceID, @DBID, @InstanceName, @DBName, 'PageVerify', 
                       d.page_verify_option_desc, 
                       'CHECKSUM', 'Unresolved', 'Page Verify should be set to CHECKSUM for data integrity.'
                FROM sys.databases d
                WHERE d.database_id = @DBID AND d.page_verify_option_desc != 'CHECKSUM'
                  AND NOT EXISTS (
                      SELECT 1 FROM SQLBestPracticeMonitoring
                      WHERE InstanceID = @InstanceID AND DBID = @DBID AND BestPracticeName = 'PageVerify' AND Status = 'Unresolved'
                  );

                -- Recovery Model Check
                UPDATE SQLBestPracticeMonitoring
                SET Status = 'Resolved',
                    CurrentValue = 'FULL',
                    Notes = 'Recovery Model is FULL.',
                    ResolvedDate = GETDATE()
                FROM SQLBestPracticeMonitoring bpm
                JOIN sys.databases d ON bpm.DBID = d.database_id
                WHERE bpm.InstanceID = @InstanceID
                  AND bpm.DBID = @DBID
                  AND bpm.BestPracticeName = 'RecoveryModel'
                  AND d.recovery_model_desc = 'FULL'
                  AND bpm.Status = 'Unresolved';

                INSERT INTO SQLBestPracticeMonitoring (InstanceID, DBID, InstanceName, DatabaseName, BestPracticeName, CurrentValue, RecommendedValue, Status, Notes)
                SELECT @InstanceID, @DBID, @InstanceName, @DBName, 'RecoveryModel', 
                       d.recovery_model_desc, 
                       'FULL', 'Unresolved', 'Recovery Model should be FULL for production databases.'
                FROM sys.databases d
                WHERE d.database_id = @DBID AND d.recovery_model_desc != 'FULL'
                  AND d.name NOT IN ('master', 'model', 'msdb', 'tempdb')
                  AND NOT EXISTS (
                      SELECT 1 FROM SQLBestPracticeMonitoring
                      WHERE InstanceID = @InstanceID AND DBID = @DBID AND BestPracticeName = 'RecoveryModel' AND Status = 'Unresolved'
                  );

                -- Add additional checks here (Auto Shrink, Trustworthy, backups, etc.) in the same pattern

            END TRY
            BEGIN CATCH
                INSERT INTO SQLBestPracticeMonitoringErrors (
                    InstanceID, DBID, DatabaseName, BestPracticeName,
                    ErrorMessage, ErrorLine, LogTime
                )
                VALUES (
                    ISNULL(@InstanceID, -1),
                    ISNULL(@DBID, -1),
                    ISNULL(@DBName, 'Unknown'),
                    'DatabaseLevel',
                    ERROR_MESSAGE(),
                    ERROR_LINE(),
                    GETDATE()
                );
                INSERT INTO @DebugLog (LogMessage, LogTime)
                VALUES ('Database-level Error in ' + @DBName + ': ' + ERROR_MESSAGE(), GETDATE());
            END CATCH

            FETCH NEXT FROM db_cursor INTO @DBID, @DBName;
        END

        CLOSE db_cursor;
        DEALLOCATE db_cursor;

        FETCH NEXT FROM instance_cursor INTO @InstanceID, @InstanceName;
    END

    CLOSE instance_cursor;
    DEALLOCATE instance_cursor;

    -- Output Debug Log
    SELECT * FROM @DebugLog ORDER BY LogTime ASC;

    -- Output summary of unresolved issues
    SELECT BestPracticeName, DatabaseName, Status, COUNT(*) AS IssueCount
    FROM SQLBestPracticeMonitoring
    WHERE Status = 'Unresolved'
    GROUP BY BestPracticeName, DatabaseName, Status
    ORDER BY BestPracticeName, DatabaseName;

    PRINT 'SQL Best Practices Check Completed at ' + CONVERT(NVARCHAR(30), GETDATE(), 120);
END
GO
