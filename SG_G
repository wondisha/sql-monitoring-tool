<#
.SYNOPSIS
SQLGuardian is a PowerShell script that monitors SQL Server instances for security and performance issues.

.DESCRIPTION
This script checks for failed logins, unencrypted databases, performance issues (slow queries, missing indexes, CPU usage),
deadlocks, blocking sessions, duplicate indexes, and analyzes query resource utilization for suggestions. It also monitors for
index fragmentation, database growth, low disk space, SQL Agent job failures/long runs, backup status, long-running transactions,
orphaned users, and server role membership. All collected data is now ingested into a central monitoring database.
It supports interactive mode and automated email alerts. The server list is retrieved dynamically from a central database table (servername).

.AUTHOR
Wondi
.VERSION
1.7 - Security and Bug Fixes. (July 18, 2025)
.LAST UPDATED
July 18, 2025 - Refactored Insert-AlertToDB to prevent SQL injection, fixed bug in Check-LongRunningTransactions, and removed redundant code.
.DEPENDENCIES
- PowerShell 5.1 or later
- SQL Server module (Invoke-Sqlcmd)
- Python 3.9+ with pandas, scikit-learn, and pickle
- Access to sysadmin role on SQL Server instances (for comprehensive monitoring)
- Access (INSERT/SELECT) to the central monitoring database (SQLGuardianMonitor)
.USAGE
# Run in automated mode (for scheduled tasks, e.g., SQL Server Agent Job)
# Ensure the account running the job has necessary SQL Server permissions and network access to LogRoot/ModelRoot.
# NEW PARAMETERS: -MonitoringDBServer and -MonitoringDBName
& "C:\Path\To\Your\Script\SQLGuardian.ps1" `
    -CentralDBServer "YourCentralDbServer" `
    -CentralDBName "YourMasterDB" `
    -LogRoot "\\Server\Share\AuditLogs" `
    -ModelRoot "\\Server\Share\Models" `
    -MonitoringDBServer "YourMonitoringDbServer" `
    -MonitoringDBName "SQLGuardianMonitor"

# Run in interactive mode
# NEW PARAMETERS: -MonitoringDBServer and -MonitoringDBName
& "C:\Path\To\Your\Script\SQLGuardian.ps1" `
    -Interactive `
    -CentralDBServer "YourCentralDbServer" `
    -CentralDBName "YourMasterDB" `
    -LogRoot "D:\AuditLogs" `
    -ModelRoot "D:\AuditLogs\Models" `
    -MonitoringDBServer "YourMonitoringDbServer" `
    -MonitoringDBName "SQLGuardianMonitor"

.NOTES
- **IMPORTANT:** Store sensitive data (e.g., SMTP credentials) securely (e.g., in a vault or encrypted file).
  The current script includes a placeholder for an encrypted password; in a production environment,
  consider using `Get-Credential`, Azure Key Vault, or a similar secure solution.
- Log files are saved to the path specified by -LogRoot (e.g., \\Server\Share\AuditLogs\AuditLogs\).
- Model file is located at the path specified by -ModelRoot (e.g., \\Server\Share\Models\login_anomaly_model.pkl).
- Query Store is highly recommended for advanced historical query analysis. This script relies on DMVs.
.TROUBLESHOOTING
- **"Unknown command" in interactive mode:** The script file might not be reloaded correctly. Close PowerShell and reopen, then re-run the script. Ensure no duplicated function definitions.
- **"Login failed" errors:** The account running the PowerShell script does not have sufficient permissions on the SQL Server instances (especially the central DB) or the new Monitoring DB. Grant `VIEW SERVER STATE`, `VIEW ANY DATABASE`, `VIEW ANY DEFINITION` or the `sysadmin` role, and `SELECT` on `servername` table. Also grant `INSERT` permissions on the `SQLGuardianMonitor` tables.
- Error: "Arithmetic overflow error converting expression to data type datetime"
  - Cause: Incorrect handling of timestamp as DATETIME instead of milliseconds.
  - Fix: Use DATEADD(MILLISECOND, timestamp, sqlserver_start_time) for conversion. (Addressed in script).
- No CPU data: Check sys.dm_os_ring_buffers for data and ensure server is running.
- Python script failures: Ensure Python is installed, path is correct, and all required libraries (pandas, scikit-learn, pickle) are installed (`pip install pandas scikit-learn`). Check Python output in logs for specific errors.
.CHANGELOG
- 2025-03-16: Initial version with basic monitoring features.
- 2025-03-16: Fixed string interpolation error in Write-Host commands using ${}.
- 2025-03-16: Resolved arithmetic overflow in CPU query by correcting timestamp conversion with DATEADD.
- 2025-03-16: Added database-driven server list from servername table.
- 2025-03-16: Added select servers command in interactive mode.
- 2025-03-16: Updated paths for network share and enhanced logging for SQL Server Agent.
- 2025-07-17: Rewritten with improved logging, robust error handling, and configuration management.
- 2025-07-17: Added Check-DuplicateIndexes, Analyze-QueryResourceUtilization, and integrated basic query suggestions.
- 2025-07-17: Full structural correction of PowerShell script, fixing nested functions and command recognition issues.
- 2025-07-17: Added: Check-IndexFragmentation, Check-DiskSpaceAndGrowth, Check-AgentJobs, Check-Backups, Check-LongRunningTransactions, Check-OrphanedUsers, Audit-ServerRoles.
- 2025-07-18: Modified all check functions to ingest data into `SQLGuardianMonitor` database tables.
- 2025-07-18: Refactored Insert-AlertToDB to prevent SQL injection, fixed bug in Check-LongRunningTransactions, and removed redundant code.
#&gt;

param (
    [string]$CentralDBServer = "Capsqldbat16v01", # Server hosting the servername table
    [string]$CentralDBName = "InstanceMonitor",           # Database containing the servername table
    [switch]$Interactive,                          # Run in interactive mode
    [string]$LogRoot = "C:\Users\e010523\Documents\Utilities",             # Root directory for all log files (e.g., D:\AuditLogs or \\Server\Share\AuditLogs)
    [string]$ModelRoot = "C:\Users\e010523\Documents\Utilities\Models",    # Root directory for Python models (e.g., D:\AuditLogs\Models or \\Server\Share\Models)
    [string]$MonitoringDBServer = "Capsqldbat16v01",        # Server for the new SQLGuardianMonitor database
    [string]$MonitoringDBName = "SQLGuardianMonitor" # Name of the new monitoring database
)

#region Global Variables and Configuration
$ServerList = @()

# Global list to store alerts generated during the script run (for immediate console/email feedback)
$script:alerts = @()


# Flag to indicate if the script is running in interactive mode
$script:InteractiveMode = $Interactive.IsPresent

# Paths for current log files (set dynamically later)
$script:interactiveLogFile = $null
$script:agentLogFile = $null

# Define the secure password BEFORE the hash table
# IMPORTANT: Replace with a secure method for password storage/retrieval in production.
$securePassword = ConvertTo-SecureString "vrwt qafv lpek kcfa" -AsPlainText -Force

# Configuration settings in a hashtable for easy access
$Config = @{
    SmtpServer          = "smtp.gmail.com"
    SmtpPort            = 587
    SmtpUsername        = "wondenad@gmail.com"
    SmtpPassword        = $securePassword
    EmailTo             = "wondenad@gmail.com"
    EmailFrom           = "wondenad@gmail.com"
    LogDir              = "$LogRoot\AuditLogs"
    ModelDir            = "$ModelRoot"
    MonitoringDBServer  = $MonitoringDBServer  # New: Central monitoring DB server
    MonitoringDBName    = $MonitoringDBName    # New: Central monitoring DB name
}

# Ensure log and model directories exist before starting operations
try {
    if (-not (Test-Path $Config.LogDir)) {
        New-Item -ItemType Directory -Path $Config.LogDir -Force | Out-Null
    }
    if (-not (Test-Path $Config.ModelDir)) {
        New-Item -ItemType Directory -Path $Config.ModelDir -Force | Out-Null
    }
} catch {
    Write-Host "ERROR: Failed to create log or model directories. Script cannot proceed. Error: $($_.Exception.Message)" -ForegroundColor Red
    Exit 1 # Exit if essential directories cannot be created
}

#endregion

#region Logging Function

# Function to centralize logging to console (if interactive) and appropriate log file
function Write-Log {
    param (
        [string]$Message,
        [string]$LogLevel = "INFO" # Log level (e.g., INFO, WARN, ERROR, DEBUG, ALERT)
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $formattedMessage = "[$timestamp] [$LogLevel] $Message"

    # Output to console if in interactive mode
    if ($script:InteractiveMode) {
        # Apply color coding for interactive mode
        switch ($LogLevel) {
            "ERROR" { Write-Host $formattedMessage -ForegroundColor Red }
            "WARN"  { Write-Host $formattedMessage -ForegroundColor Yellow }
            "ALERT" { Write-Host $formattedMessage -ForegroundColor Magenta }
            "DEBUG" { Write-Host $formattedMessage -ForegroundColor DarkGray }
            default { Write-Host $formattedMessage }
        }
    }

    # Output to the relevant log file
    # Prioritize interactive log if in interactive mode, otherwise use agent log, fallback to general.
    if ($script:InteractiveMode -and ($script:interactiveLogFile -ne $null) -and (Test-Path $script:interactiveLogFile)) {
        Add-Content -Path $script:interactiveLogFile -Value $formattedMessage
    } elseif ($script:agentLogFile -ne $null -and (Test-Path $script:agentLogFile)) {
        Add-Content -Path $script:agentLogFile -Value $formattedMessage
    }
    # Fallback to a general log if no specific log file is set (e.g., during initial setup errors)
    else {
        Add-Content -Path "$($Config.LogDir)\SQLGuardian_General.log" -Value $formattedMessage
    }
}

#endregion

#region Core Monitoring Functions

# Helper function to insert an alert into the central monitoring database
function Insert-AlertToDB {
    param (
        [string]$ServerName,
        [string]$AlertLevel,
        [string]$AlertCategory,
        [string]$Message
    )
    $query = "INSERT INTO [dbo].[Alerts] (ServerName, AlertLevel, AlertCategory, Message) VALUES (@ServerName, @AlertLevel, @AlertCategory, @Message);"
    try {
        Invoke-Sqlcmd -ServerInstance $Config.MonitoringDBServer -Database $Config.MonitoringDBName `
            -Query $query -TrustServerCertificate -ErrorAction Stop `
            -Variable @(
                "ServerName=$ServerName",
                "AlertLevel=$AlertLevel",
                "AlertCategory=$AlertCategory",
                "Message=$Message"
            ) | Out-Null
        Write-Log "Alert inserted to Monitoring DB." "INFO"
    } catch {
        Write-Log "ERROR: Failed to insert alert to Monitoring DB. ERROR: $($_.Exception.Message)" "ERROR"
    }
}
# Function to retrieve the list of SQL Server instances from a central database table
function Get-ServerListFromDB {
    param (
        [string]$Server,
        [string]$Database
    )
    $query = "SELECT ServerName FROM servername;"
    try {
        Write-Log "Attempting to retrieve server list from $Server.$Database..." "INFO"
        $servers = Invoke-Sqlcmd -ServerInstance $Server -Database $Database -Query $query -TrustServerCertificate -ErrorAction Stop
        Write-Log "Successfully retrieved server list from $Server.$Database." "INFO"
        return $servers | Select-Object -ExpandProperty ServerName
    } catch {
        $errorMessage = "ERROR: Failed to retrieve server list from database '$Server.$Database'. Error: $($_.Exception.Message). Falling back to default list."
        Write-Log $errorMessage "ERROR"
        return @('capsqldbat16v01', 'AO2017TEST-02G1\AOSQL2017TEST02', 'DALTESTSQL22V01\AOSQL2022TEST01') # Fallback list
    }
}

# Function to check for failed login attempts from SQL Server Error Log
function Check-FailedLogins {
    param (
        [string]$ServerName,
        [int]$TimeWindowMinutes = 15
    )
    $query = "EXEC sp_readerrorlog 0, 1, 'Login failed';"
    $logFile = "$($Config.LogDir)\FailedLogins_$ServerName.csv"
    $captureTime = Get-Date

    try {
        Write-Log "[$ServerName] Checking for failed login attempts..." "INFO"
        $errorLog = Invoke-Sqlcmd -ServerInstance $ServerName -Database "master" -Query $query -TrustServerCertificate -ErrorAction Stop

        if ($null -eq $errorLog) {
            $script:alerts += "[$ServerName] Warning: Unable to read error log for failed logins. Check permissions or log availability."
            Write-Log "[$ServerName] WARN: Unable to read error log for failed logins. Check permissions or log availability." "WARN"
            Insert-AlertToDB -ServerName $ServerName -AlertLevel "WARN" -AlertCategory "Security" -Message "Unable to read error log for failed logins. Check permissions or log availability."
            return
        }

        if (-not (Test-Path $logFile)) {
            "Timestamp,User,Reason,ClientIP,ServerName" | Out-File $logFile -Encoding UTF8
            Write-Log "[$ServerName] Created new FailedLogins CSV file: $logFile" "DEBUG"
        }

        $failedLogins = @()
        foreach ($log in $errorLog) {
            if ($log.Text -match "Login failed for user '?(.*?)(?:'| Reason)") {
                $user = $matches[1]
                $reason = if ($log.Text -match "Reason: (.*?)\.") { $matches[1] } else { "Unknown" }
                $clientIP = if ($log.Text -match "client: (.*?)\]") { $matches[1] } else { "Unknown" }
                $failedLogins += [PSCustomObject]@{
                    Timestamp  = $log.LogDate.ToString("MM/dd/yyyy HH:mm:ss")
                    User       = $user
                    Reason     = $reason
                    ClientIP   = $clientIP
                    ServerName = $ServerName
                }
            }
        }

        if ($failedLogins.Count -gt 0) {
            $failedLogins | Export-Csv $logFile -NoTypeInformation -Append -Encoding UTF8
            Write-Log "[$ServerName] INFO: $($failedLogins.Count) failed login(s) recorded in the last $TimeWindowMinutes minutes and exported to CSV." "INFO"
            $script:alerts += "[$ServerName] Info: $($failedLogins.Count) failed login(s) recorded in the last $TimeWindowMinutes minutes."
            
            # Insert into Alerts table for each failed login
            foreach ($fl in $failedLogins) {
                Insert-AlertToDB -ServerName $ServerName -AlertLevel "INFO" -AlertCategory "Security:FailedLogin" -Message "Login failed for user '$($fl.User)' from IP $($fl.ClientIP). Reason: $($fl.Reason)."
            }

        } else {
            Write-Log "[$ServerName] INFO: No new failed logins detected." "INFO"
        }
    } catch {
        Write-Log "[$ServerName] ERROR: Failed to check error log for failed logins. Error: $($_.Exception.Message)" "ERROR"
        $script:alerts += "[$ServerName] Warning: Failed to check error log. Error: $($_.Exception.Message)"
        Insert-AlertToDB -ServerName $ServerName -AlertLevel "ERROR" -AlertCategory "Security" -Message "Failed to read error log for failed logins. Error: $($_.Exception.Message)"
    }
}

# Function to check encryption status of user databases
function Check-EncryptionStatus {
    param (
        [string]$ServerName
    )
    $query = @"
    SELECT
        name,
        is_encrypted
    FROM sys.databases
    WHERE is_encrypted = 0
    AND name NOT IN ('master', 'model', 'msdb', 'tempdb');
"@
    try {
        Write-Log "[$ServerName] Checking encryption status for user databases..." "INFO"
        $unencryptedDbs = Invoke-Sqlcmd -ServerInstance $ServerName -Database "master" -Query $query -TrustServerCertificate -ErrorAction Stop
        if ($null -eq $unencryptedDbs) {
            $script:alerts += "[$ServerName] Warning: Unable to check encryption status. Check permissions or database availability."
            Write-Log "[$ServerName] WARN: Unable to check encryption status. Result was null. Check permissions." "WARN"
            Insert-AlertToDB -ServerName $ServerName -AlertLevel "WARN" -AlertCategory "Security:Encryption" -Message "Unable to check encryption status. Check permissions."
            return
        }

        if ($unencryptedDbs.Count -gt 0) {
            foreach ($db in $unencryptedDbs) {
                $alertMessage = "Database '$($db.name)' is not encrypted. Recommend enabling Transparent Data Encryption (TDE)."
                $script:alerts += "[$ServerName] Security Alert: " + $alertMessage
                Write-Log "[$ServerName] Security Alert: " + $alertMessage "ALERT"
                Insert-AlertToDB -ServerName $ServerName -AlertLevel "ALERT" -AlertCategory "Security:Encryption" -Message $alertMessage
            }
        } else {
            Write-Log "[$ServerName] INFO: All user databases are encrypted." "INFO"
        }
    } catch {
        Write-Log "[$ServerName] ERROR: Failed to check encryption status. Error: $($_.Exception.Message)" "ERROR"
        $script:alerts += "[$ServerName] Warning: Failed to check encryption status. Error: $($_.Exception.Message)"
        Insert-AlertToDB -ServerName $ServerName -AlertLevel "ERROR" -AlertCategory "Security:Encryption" -Message "Failed to check encryption status. Error: $($_.Exception.Message)"
    }
}

# Function to check performance metrics (slow queries, missing indexes, CPU usage)
function Check-Performance {
    param (
        [string]$ServerName
    )
    # Query to find top 20 slow queries by total worker time
    $slowQuery = @"
    SELECT TOP 20
        t.text AS query_text,
        qs.execution_count,
        qs.total_worker_time / 1000 AS total_worker_time_ms,
        qs.total_worker_time / qs.execution_count / 1000 AS avg_worker_time_ms
    FROM sys.dm_exec_query_stats qs
    CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) t
    ORDER BY qs.total_worker_time DESC;
"@
    # Query to find missing indexes with high impact
    $indexQuery = @"
    SELECT
        DB_NAME(mid.database_id) AS database_name,
        migs.avg_user_impact,
        mid.statement AS table_name,
        mid.equality_columns,
        mid.inequality_columns
    FROM sys.dm_db_missing_index_group_stats migs
    JOIN sys.dm_db_missing_index_groups mig ON migs.group_handle = mig.index_group_handle
    JOIN sys.dm_db_missing_index_details mid ON mig.index_handle = mid.index_handle
    JOIN sys.databases d ON mid.database_id = d.database_id
    WHERE migs.avg_user_impact &gt; 50 -- Filter for high impact indexes
    AND d.name NOT IN ('master', 'model', 'msdb', 'tempdb')
    ORDER BY migs.avg_user_impact DESC;
"@
    # Query to get CPU usage from ring buffers for the last 15 minutes
    $cpuQuery = @"
    SELECT
        AVG(CAST(record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') AS DECIMAL(5,2))) AS SystemIdlePercent,
        AVG(CAST(record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int') AS DECIMAL(5,2))) AS SQLProcessUtilizationPercent
    FROM (
        SELECT
            DATEADD(MILLISECOND, rb.timestamp - si.ms_ticks, GETDATE()) AS actual_timestamp,
            CONVERT(XML, rb.record) AS record
        FROM sys.dm_os_ring_buffers rb
        CROSS JOIN sys.dm_os_sys_info si
        WHERE rb.ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'
        AND rb.record LIKE '%&lt;SystemHealth&gt;%'
    ) AS RingBuffer
    WHERE actual_timestamp &gt; DATEADD(MINUTE, -15, GETDATE());
"@

    # Check Slow Queries
    try {
        Write-Log "[$ServerName] Checking for slow queries..." "INFO"
        $slowQueries = Invoke-Sqlcmd -ServerInstance $ServerName -Database "master" -Query $slowQuery -TrustServerCertificate -ErrorAction Stop
        if ($null -eq $slowQueries) {
            $script:alerts += "[$ServerName] Warning: Unable to check slow queries. Check VIEW SERVER STATE permission."
            Write-Log "[$ServerName] WARN: Unable to check slow queries. Result was null. Check VIEW SERVER STATE permission." "WARN"
            Insert-AlertToDB -ServerName $ServerName -AlertLevel "WARN" -AlertCategory "Performance:Query" -Message "Unable to check slow queries. Check VIEW SERVER STATE permission."
        } elseif ($slowQueries.Count -gt 0) {
            foreach ($query in $slowQueries) {
                if ($query.avg_worker_time_ms -gt 20) { # Threshold for alert (20ms avg CPU time)
                    $queryPreview = ($query.query_text.Substring(0, [Math]::Min(100, $query.query_text.Length))).Replace("`r`n", " ").Replace("`n", " ")
                    $alertMessage = "Query '$queryPreview...' ran $($query.execution_count) times, total CPU time: $($query.total_worker_time_ms)ms, avg CPU time: $($query.avg_worker_time_ms)ms. Suggestion: Investigate this query for optimization (e.g., add indexes, rewrite query)."
                    $script:alerts += "[$ServerName] Performance Alert: " + $alertMessage
                    Write-Log "[$ServerName] Performance Alert: " + $alertMessage "ALERT"
                    Insert-AlertToDB -ServerName $ServerName -AlertLevel "ALERT" -AlertCategory "Performance:SlowQuery" -Message $alertMessage
                    # Store in QueryPerformanceMetrics (if you later want to populate all fields)
                    # For now, just alerts from this specific check
                }
            }
        } else {
            Write-Log "[$ServerName] INFO: No significantly slow queries detected." "INFO"
        }
    } catch {
        Write-Log "[$ServerName] ERROR: Failed to query slow queries. Error: $($_.Exception.Message)" "ERROR"
        $script:alerts += "[$ServerName] Warning: Failed to query slow queries. Error: $($_.Exception.Message)"
        Insert-AlertToDB -ServerName $ServerName -AlertLevel "ERROR" -AlertCategory "Performance:Query" -Message "Failed to query slow queries. Error: $($_.Exception.Message)"
    }

    # Check Missing Indexes (already provides suggestions)
    try {
        Write-Log "[$ServerName] Checking for missing indexes..." "INFO"
        $missingIndexes = Invoke-Sqlcmd -ServerInstance $ServerName -Database "master" -Query $indexQuery -TrustServerCertificate -ErrorAction Stop
        if ($missingIndexes -and $missingIndexes.Count -gt 0) {
            foreach ($index in $missingIndexes) {
                $alertMessage = "Missing index in database '$($index.database_name)' on '$($index.table_name)' with impact $($index.avg_user_impact)%. Suggestion: Consider creating an index on columns: $($index.equality_columns) INCLUDES ($($index.inequality_columns))."
                $script:alerts += "[$ServerName] Performance Alert: " + $alertMessage
                Write-Log "[$ServerName] Performance Alert: " + $alertMessage "ALERT"
                Insert-AlertToDB -ServerName $ServerName -AlertLevel "ALERT" -AlertCategory "Performance:MissingIndex" -Message $alertMessage
            }
        } else {
            Write-Log "[$ServerName] INFO: No missing indexes detected with impact > 50% in any user database." "INFO"
        }
    } catch {
        Write-Log "[$ServerName] ERROR: Failed to query missing indexes. Error: $($_.Exception.Message)" "ERROR"
        $script:alerts += "[$ServerName] Warning: Failed to query missing indexes. Error: $($_.Exception.Message)"
        Insert-AlertToDB -ServerName $ServerName -AlertLevel "ERROR" -AlertCategory "Performance:MissingIndex" -Message "Failed to query missing indexes. Error: $($_.Exception.Message)"
    }

    # Check CPU Usage
    try {
        Write-Log "[$ServerName] Checking CPU usage..." "INFO"
        $cpuUsage = Invoke-Sqlcmd -ServerInstance $ServerName -Database "master" -Query $cpuQuery -TrustServerCertificate -ErrorAction Stop
        if ($cpuUsage -and ($cpuUsage.SystemIdlePercent -ne $null) -and ($cpuUsage.SQLProcessUtilizationPercent -ne $null)) {
            Write-Log "[$ServerName] INFO: CPU Usage (last 15 minutes): System Idle: $($cpuUsage.SystemIdlePercent)%, SQL Process Utilization: $($cpuUsage.SQLProcessUtilizationPercent)%" "INFO"
            if ($cpuUsage.SQLProcessUtilizationPercent -gt 80) { # High CPU usage threshold
                $alertMessage = "High SQL Server CPU usage detected ($($cpuUsage.SQLProcessUtilizationPercent)% > 80%) over the last 15 minutes. Suggestion: Investigate active queries and server workload using Query Store or activity monitor."
                $script:alerts += "[$ServerName] Performance Alert: " + $alertMessage
                Write-Log "[$ServerName] Performance Alert: " + $alertMessage "ALERT"
                Insert-AlertToDB -ServerName $ServerName -AlertLevel "ALERT" -AlertCategory "Performance:CPU" -Message $alertMessage
            }
        } else {
            $script:alerts += "[$ServerName] Warning: No valid CPU usage data available for the last 15 minutes."
            Write-Log "[$ServerName] WARN: No valid CPU usage data available for the last 15 minutes." "WARN"
            Insert-AlertToDB -ServerName $ServerName -AlertLevel "WARN" -AlertCategory "Performance:CPU" -Message "No valid CPU usage data available for the last 15 minutes."
        }
    } catch {
        $errorMessage = "Failed to retrieve CPU usage. Error: $($_.Exception.Message)"
        Write-Log "[$ServerName] ERROR: " + $errorMessage "ERROR"
        Write-Log "[$ServerName] DEBUG: SQL Error Details: $($_.Exception.InnerException.Message)" "DEBUG"
        Write-Log "[$ServerName] INFO: Skipping CPU usage check due to error." "INFO"
        $script:alerts += "[$ServerName] Warning: " + $errorMessage
        Insert-AlertToDB -ServerName $ServerName -AlertLevel "ERROR" -AlertCategory "Performance:CPU" -Message "Failed to retrieve CPU usage. Error: $($_.Exception.Message)"
    }
}

# Function to check for deadlocks using Extended Events
function Check-Deadlocks {
    param (
        [string]$ServerName
    )
    $deadlockQuery = @"
    DECLARE @xml XML;
    SELECT @xml = target_data
    FROM sys.dm_xe_session_targets xt
    JOIN sys.dm_xe_sessions xs ON xs.address = xt.event_session_address
    WHERE xs.name = 'system_health'
    AND xt.target_name = 'ring_buffer';

    SELECT
        XEventData.XEvent.value('(data/value)[1]', 'NVARCHAR(MAX)') AS deadlock_graph,
        XEventData.XEvent.value('@timestamp', 'DATETIME') AS event_time
    FROM @xml.nodes('//RingBufferTarget/event[@name="xml_deadlock_report"]') AS XEventData(XEvent)
    ORDER BY event_time DESC;
"@
    try {
        Write-Log "[$ServerName] Checking for recent deadlocks..." "INFO"
        $deadlocks = Invoke-Sqlcmd -ServerInstance $ServerName -Database "master" -Query $deadlockQuery -TrustServerCertificate -ErrorAction Stop
        if ($deadlocks -and $deadlocks.Count -gt 0) {
            Write-Log "[$ServerName] ALERTS: Found $($deadlocks.Count) deadlock(s):" "ALERT"
            foreach ($deadlock in $deadlocks) {
                $timestamp = $deadlock.event_time.ToString('yyyyMMdd_HHmmss')
                $deadlockFileName = "$($Config.LogDir)\Deadlock_$ServerName_$timestamp.xml"
                $deadlock.deadlock_graph | Out-File -FilePath $deadlockFileName -Encoding UTF8 # Save full XML

                $deadlockPreview = ($deadlock.deadlock_graph.Substring(0, [Math]::Min(200, $deadlock.deadlock_graph.Length))).Replace("`r`n", " ").Replace("`n", " ")

                $alertMessage = "Deadlock detected at $($deadlock.event_time). Details saved to $deadlockFileName. Preview: $deadlockPreview..."
                $script:alerts += "[$ServerName] Deadlock Alert: " + $alertMessage
                Write-Log "[$ServerName] Deadlock Alert: " + $alertMessage "ALERT"
                Insert-AlertToDB -ServerName $ServerName -AlertLevel "ALERT" -AlertCategory "Performance:Deadlock" -Message $alertMessage
            }
        } else {
            Write-Log "[$ServerName] INFO: No recent deadlocks detected." "INFO"
        }
    } catch {
        Write-Log "[$ServerName] ERROR: Failed to check deadlocks. Error: $($_.Exception.Message)" "ERROR"
        $script:alerts += "[$ServerName] Warning: Failed to check deadlocks. Error: $($_.Exception.Message)"
        Insert-AlertToDB -ServerName $ServerName -AlertLevel "ERROR" -AlertCategory "Performance:Deadlock" -Message "Failed to check deadlocks. Error: $($_.Exception.Message)"
    }
}

# Function to check for blocking sessions
function Check-BlockingSessions {
    param (
        [string]$ServerName
    )
    $blockingQuery = @"
    SELECT
        r.blocking_session_id AS BlockingSessionID,
        r.session_id AS BlockedSessionID,
        DB_NAME(r.database_id) AS DatabaseName,
        CASE
            WHEN r.wait_resource LIKE 'OBJECT:%' THEN
                OBJECT_NAME(CAST(PARSENAME(r.wait_resource, 1) AS INT), r.database_id)
            ELSE r.wait_resource
        END AS ResourceAffected,
        r.wait_type,
        r.wait_time AS WaitTimeMS,
        (SELECT text FROM sys.dm_exec_sql_text(r.sql_handle)) AS BlockedQuery,
        (SELECT text FROM sys.dm_exec_sql_text(c.most_recent_sql_handle)) AS BlockingQuery
    FROM sys.dm_exec_requests r
    LEFT JOIN sys.dm_exec_sessions s ON r.blocking_session_id = s.session_id
    LEFT JOIN sys.dm_exec_connections c ON s.session_id = c.session_id
    WHERE r.blocking_session_id <> 0;
"@
    try {
        Write-Log "[$ServerName] Checking for blocking sessions..." "INFO"
        $blockingSessions = Invoke-Sqlcmd -ServerInstance $ServerName -Database "master" -Query $blockingQuery -TrustServerCertificate -ErrorAction Stop
        if ($blockingSessions -and $blockingSessions.Count -gt 0) {
            Write-Log "[$ServerName] ALERTS: Current blocking sessions detected:" "ALERT"
            foreach ($session in $blockingSessions) {
                $blockedQueryPreview = ($session.BlockedQuery.Substring(0, [Math]::Min(100, $session.BlockedQuery.Length))).Replace("`r`n", " ").Replace("`n", " ")
                $blockingQueryPreview = ($session.BlockingQuery.Substring(0, [Math]::Min(100, $session.BlockingQuery.Length))).Replace("`r`n", " ").Replace("`n", " ")

                $alertMessage = "BlockingSessionID: $($session.BlockingSessionID), BlockedSessionID: $($session.BlockedSessionID). Database: $($session.DatabaseName), Resource: $($session.ResourceAffected), WaitType: $($session.wait_type), WaitTime: $($session.WaitTimeMS)ms. Blocked Query: $blockedQueryPreview..., Blocking Query: $blockingQueryPreview.... Suggestion: Investigate the blocking query and consider transaction isolation levels."
                $script:alerts += "[$ServerName] Blocking Alert: " + $alertMessage
                Write-Log "[$ServerName] Blocking Alert: " + $alertMessage "ALERT"
                Insert-AlertToDB -ServerName $ServerName -AlertLevel "ALERT" -AlertCategory "Performance:Blocking" -Message $alertMessage
            }
        } else {
            Write-Log "[$ServerName] INFO: No blocking sessions detected." "INFO"
        }
    } catch {
        Write-Log "[$ServerName] ERROR: Failed to check blocking sessions. Error: $($_.Exception.Message)" "ERROR"
        $script:alerts += "[$ServerName] Warning: Failed to check blocking sessions. Error: $($_.Exception.Message)"
        Insert-AlertToDB -ServerName $ServerName -AlertLevel "ERROR" -AlertCategory "Performance:Blocking" -Message "Failed to check blocking sessions. Error: $($_.Exception.Message)"
    }
}

# Function to detect duplicate indexes
function Check-DuplicateIndexes {
    param (
        [string]$ServerName
    )
    $duplicateIndexQuery = @"
    WITH IndexColumns AS (
        SELECT
            DB_ID() AS database_id,
            i.object_id,
            OBJECT_SCHEMA_NAME(i.object_id) AS SchemaName,
            OBJECT_NAME(i.object_id) AS TableName,
            i.index_id,
            i.name AS IndexName,
            i.type_desc,
            STUFF((
                SELECT ', ' + COL_NAME(ic.object_id, ic.column_id) +
                       CASE WHEN ic.is_descending_key = 1 THEN ' DESC' ELSE ' ASC' END
                FROM sys.index_columns ic
                WHERE ic.object_id = i.object_id AND ic.index_id = i.index_id AND ic.is_included_column = 0
                ORDER BY ic.key_ordinal
                FOR XML PATH('')
            ), 1, 2, '') AS KeyColumns,
            STUFF((
                SELECT ', ' + COL_NAME(ic.object_id, ic.column_id)
                FROM sys.index_columns ic
                WHERE ic.object_id = i.object_id AND ic.index_id = i.index_id AND ic.is_included_column = 1
                ORDER BY ic.column_id
                FOR XML PATH('')
            ), 1, 2, '') AS IncludedColumns
        FROM sys.indexes i
        WHERE i.is_hypothetical = 0
          AND i.is_primary_key = 0
          AND i.is_unique_constraint = 0
          AND i.type IN (1, 2)
    ),
    DuplicateSignatures AS (
        SELECT
            SchemaName,
            TableName,
            KeyColumns,
            IncludedColumns,
            COUNT(*) AS NumberOfDuplicates
        FROM IndexColumns
        WHERE KeyColumns IS NOT NULL
        GROUP BY SchemaName, TableName, KeyColumns, IncludedColumns
        HAVING COUNT(*) > 1
    )
    SELECT
        ds.SchemaName,
        ds.TableName,
        ds.KeyColumns,
        ds.IncludedColumns,
        ds.NumberOfDuplicates,
        STUFF((
            SELECT ', ' + ic.IndexName + ' (' + ic.type_desc + ')'
            FROM IndexColumns ic
            WHERE ic.SchemaName = ds.SchemaName
              AND ic.TableName = ds.TableName
              AND ic.KeyColumns = ds.KeyColumns
              AND ISNULL(ic.IncludedColumns, '') = ISNULL(ds.IncludedColumns, '')
            ORDER BY ic.IndexName
            FOR XML PATH('')
        ), 1, 2, '') AS DuplicateIndexesList
    FROM DuplicateSignatures ds
    ORDER BY ds.SchemaName, ds.TableName, ds.KeyColumns;
"@

    try {
        Write-Log "[$ServerName] Checking for duplicate indexes across user databases..." "INFO"
        $dbQuery = "SELECT name FROM sys.databases WHERE database_id > 4 AND state = 0;"
        $userDatabases = Invoke-Sqlcmd -ServerInstance $ServerName -Database "master" -Query $dbQuery -TrustServerCertificate -ErrorAction Stop

        $allDuplicateIndexes = @()
        foreach ($db in $userDatabases) {
            $dbName = $db.name
            Write-Log "[$ServerName] Checking database '$dbName' for duplicate indexes..." "DEBUG"
            $duplicates = Invoke-Sqlcmd -ServerInstance $ServerName -Database $dbName -Query $duplicateIndexQuery -TrustServerCertificate -ErrorAction Stop -MaxCharLength 2147483647
            if ($duplicates -and $duplicates.Count -gt 0) {
                $allDuplicateIndexes += $duplicates | Select-Object @{N='DatabaseName';E={$dbName}}, SchemaName, TableName, KeyColumns, IncludedColumns, NumberOfDuplicates, DuplicateIndexesList
            }
        }

        if ($allDuplicateIndexes.Count -gt 0) {
            Write-Log "[$ServerName] ALERTS: Duplicate indexes detected:" "ALERT"
            foreach ($duplicate in $allDuplicateIndexes) {
                $alertMessage = "Duplicate Index Alert: Database: $($duplicate.DatabaseName), Table: $($duplicate.SchemaName).$($duplicate.TableName), Keys: '$($duplicate.KeyColumns)', Includes: '$($duplicate.IncludedColumns)'. Duplicates found: $($duplicate.DuplicateIndexesList). Suggestion: Consider dropping one of the duplicate non-clustered indexes to improve write performance and storage efficiency. Verify usage (sys.dm_db_index_usage_stats) before dropping."
                $script:alerts += "[$ServerName] " + $alertMessage
                Write-Log "[$ServerName] " + $alertMessage "ALERT"
                Insert-AlertToDB -ServerName $ServerName -AlertLevel "ALERT" -AlertCategory "Performance:DuplicateIndex" -Message $alertMessage
                # Insert into DuplicateIndexes table
                $insertQuery = "INSERT INTO [dbo].[DuplicateIndexes] (ServerName, DatabaseName, SchemaName, TableName, KeyColumns, IncludedColumns, NumberOfDuplicates, DuplicateIndexesList) VALUES (@ServerName, @DatabaseName, @SchemaName, @TableName, @KeyColumns, @IncludedColumns, @NumberOfDuplicates, @DuplicateIndexesList);"
                Invoke-Sqlcmd -ServerInstance $Config.MonitoringDBServer -Database $Config.MonitoringDBName `
                    -Query $insertQuery -TrustServerCertificate -ErrorAction SilentlyContinue `
                    -Variable @(
                        "ServerName=$ServerName",
                        "DatabaseName=$($duplicate.DatabaseName)",
                        "SchemaName=$($duplicate.SchemaName)",
                        "TableName=$($duplicate.TableName)",
                        "KeyColumns=$($duplicate.KeyColumns)",
                        "IncludedColumns=$($duplicate.IncludedColumns)",
                        "NumberOfDuplicates=$($duplicate.NumberOfDuplicates)",
                        "DuplicateIndexesList=$($duplicate.DuplicateIndexesList)"
                    ) | Out-Null
            }
        } else {
            Write-Log "[$ServerName] INFO: No duplicate indexes found in user databases." "INFO"
        }
    } catch {
        Write-Log "[$ServerName] ERROR: Failed to check for duplicate indexes. Error: $($_.Exception.Message)" "ERROR"
        $script:alerts += "[$ServerName] Warning: Failed to check for duplicate indexes. Error: $($_.Exception.Message)"
        Insert-AlertToDB -ServerName $ServerName -AlertLevel "ERROR" -AlertCategory "Performance:DuplicateIndex" -Message "Failed to check for duplicate indexes. Error: $($_.Exception.Message)"
    }
}

# Function to analyze query resource utilization and provide suggestions
function Analyze-QueryResourceUtilization {
    param (
        [string]$ServerName
    )
    $cpuQuery = @"
    SELECT TOP 20
        qs.creation_time,
        qs.last_execution_time,
        qs.execution_count,
        (qs.total_worker_time / 1000000.0) AS total_cpu_s,
        (qs.total_worker_time / (qs.execution_count * 1000000.0)) AS avg_cpu_s,
        (qs.total_logical_reads / qs.execution_count) AS avg_logical_reads,
        (qs.total_logical_writes / qs.execution_count) AS avg_logical_writes,
        DB_NAME(t.dbid) AS DatabaseName,
        t.text AS query_text,
        qp.query_plan AS QueryPlanXML
    FROM sys.dm_exec_query_stats qs
    CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) t
    CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp
    WHERE t.dbid IS NOT NULL AND DB_NAME(t.dbid) NOT IN ('master', 'model', 'msdb', 'tempdb')
    ORDER BY qs.total_worker_time DESC;
"@

    $ioQuery = @"
    SELECT TOP 20
        qs.creation_time,
        qs.last_execution_time,
        qs.execution_count,
        qs.total_logical_reads,
        (qs.total_logical_reads / qs.execution_count) AS avg_logical_reads,
        (qs.total_logical_writes / qs.execution_count) AS avg_logical_writes,
        (qs.total_worker_time / 1000000.0) AS total_cpu_s,
        DB_NAME(t.dbid) AS DatabaseName,
        t.text AS query_text,
        qp.query_plan AS QueryPlanXML
    FROM sys.dm_exec_query_stats qs
    CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) t
    CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp
    WHERE t.dbid IS NOT NULL AND DB_NAME(t.dbid) NOT IN ('master', 'model', 'msdb', 'tempdb')
    ORDER BY qs.total_logical_reads DESC;
"@

    $waitQuery = @"
    SELECT TOP 20
        r.session_id,
        r.status,
        r.command,
        DB_NAME(r.database_id) AS DatabaseName,
        r.wait_type,
        r.wait_time AS WaitTimeMs,
        r.last_wait_type,
        r.blocking_session_id,
        (SELECT text FROM sys.dm_exec_sql_text(r.sql_handle)) AS query_text,
        (SELECT query_plan FROM sys.dm_exec_query_plan(r.plan_handle)) AS QueryPlanXML
    FROM sys.dm_exec_requests r
    WHERE r.session_id <> @@SPID
    AND r.status IN ('running', 'suspended')
    AND r.wait_type IS NOT NULL
    ORDER BY r.wait_time DESC;
"@

    # 1. Top CPU Consuming Queries
    try {
        Write-Log "[$ServerName] Analyzing top CPU consuming queries..." "INFO"
        $cpuQueries = Invoke-Sqlcmd -ServerInstance $ServerName -Database "master" -Query $cpuQuery -TrustServerCertificate -ErrorAction Stop -MaxCharLength 2147483647
        if ($cpuQueries -and $cpuQueries.Count -gt 0) {
            Write-Log "[$ServerName] Top 20 CPU Consuming Queries (Avg CPU > 0.05s):" "INFO"
            foreach ($query in $cpuQueries) {
                $queryPreview = ($query.query_text.Substring(0, [Math]::Min(100, $query.query_text.Length))).Replace("`r`n", " ").Replace("`n", " ")
                $alertMessage = "High CPU Query (DB: $($query.DatabaseName)): Avg CPU: $($query.avg_cpu_s)s, Total CPU: $($query.total_cpu_s)s, Exec Count: $($query.execution_count). Query: $queryPreview.... Suggestion: Review execution plan, consider indexing or rewriting."
                
                # Insert into QueryPerformanceMetrics table
                $insertQuery = "INSERT INTO [dbo].[QueryPerformanceMetrics] (ServerName, DatabaseName, QueryText, ExecutionCount, TotalCpuSeconds, AvgCpuSeconds, AvgLogicalReads, AvgLogicalWrites, QueryCategory, ExecutionPlanXML) VALUES (@ServerName, @DatabaseName, @QueryText, @ExecutionCount, @TotalCpuSeconds, @AvgCpuSeconds, @AvgLogicalReads, @AvgLogicalWrites, @QueryCategory, @ExecutionPlanXML);"
                Invoke-Sqlcmd -ServerInstance $Config.MonitoringDBServer -Database $Config.MonitoringDBName `
                    -Query $insertQuery -TrustServerCertificate -ErrorAction SilentlyContinue `
                    -Variable @(
                        "ServerName=$ServerName",
                        "DatabaseName=$($query.DatabaseName)",
                        "QueryText=$($query.query_text)",
                        "ExecutionCount=$($query.execution_count)",
                        "TotalCpuSeconds=$($query.total_cpu_s)",
                        "AvgCpuSeconds=$($query.avg_cpu_s)",
                        "AvgLogicalReads=$($query.avg_logical_reads)",
                        "AvgLogicalWrites=$($query.avg_logical_writes)",
                        "QueryCategory='CPU'",
                        "ExecutionPlanXML=$($query.QueryPlanXML)"
                    ) | Out-Null

                if ($query.avg_cpu_s -gt 0.05) { # Threshold for alert
                    $script:alerts += "[$ServerName] Performance Alert: " + $alertMessage
                    Write-Log "[$ServerName] Performance Alert: " + $alertMessage "ALERT"
                    Insert-AlertToDB -ServerName $ServerName -AlertLevel "ALERT" -AlertCategory "Performance:HighCPUQuery" -Message $alertMessage
                } else {
                    Write-Log "[$ServerName] INFO: CPU: $($query.avg_cpu_s)s, Reads: $($query.avg_logical_reads), Query: $queryPreview..." "INFO"
                }
            }
        } else {
            Write-Log "[$ServerName] INFO: No significant CPU consuming queries found." "INFO"
        }
    } catch {
        Write-Log "[$ServerName] ERROR: Failed to analyze CPU queries. Error: $($_.Exception.Message)" "ERROR"
        $script:alerts += "[$ServerName] Warning: Failed to analyze CPU queries. Error: $($_.Exception.Message)"
        Insert-AlertToDB -ServerName $ServerName -AlertLevel "ERROR" -AlertCategory "Performance:QueryAnalysis" -Message "Failed to analyze CPU queries. Error: $($_.Exception.Message)"
    }

    # 2. Top I/O Consuming Queries
    try {
        Write-Log "[$ServerName] Analyzing top I/O consuming queries..." "INFO"
        $ioQueries = Invoke-Sqlcmd -ServerInstance $ServerName -Database "master" -Query $ioQuery -TrustServerCertificate -ErrorAction Stop -MaxCharLength 2147483647
        if ($ioQueries -and $ioQueries.Count -gt 0) {
            Write-Log "[$ServerName] Top 20 I/O Consuming Queries (Avg Logical Reads > 1000):" "INFO"
            foreach ($query in $ioQueries) {
                $queryPreview = ($query.query_text.Substring(0, [Math]::Min(100, $query.query_text.Length))).Replace("`r`n", " ").Replace("`n", " ")
                $alertMessage = "High I/O Query (DB: $($query.DatabaseName)): Avg Logical Reads: $($query.avg_logical_reads), Avg Logical Writes: $($query.avg_logical_writes), Exec Count: $($query.execution_count). Query: $queryPreview.... Suggestion: Optimize for I/O, check for missing indexes, or consider covering indexes."

                # Insert into QueryPerformanceMetrics table
                $insertQuery = "INSERT INTO [dbo].[QueryPerformanceMetrics] (ServerName, DatabaseName, QueryText, ExecutionCount, TotalCpuSeconds, AvgCpuSeconds, AvgLogicalReads, AvgLogicalWrites, QueryCategory, ExecutionPlanXML) VALUES (@ServerName, @DatabaseName, @QueryText, @ExecutionCount, @TotalCpuSeconds, @AvgCpuSeconds, @AvgLogicalReads, @AvgLogicalWrites, @QueryCategory, @ExecutionPlanXML);"
                Invoke-Sqlcmd -ServerInstance $Config.MonitoringDBServer -Database $Config.MonitoringDBName `
                    -Query $insertQuery -TrustServerCertificate -ErrorAction SilentlyContinue `
                    -Variable @(
                        "ServerName=$ServerName",
                        "DatabaseName=$($query.DatabaseName)",
                        "QueryText=$($query.query_text)",
                        "ExecutionCount=$($query.execution_count)",
                        "TotalCpuSeconds=$($query.total_cpu_s)",
                        "AvgCpuSeconds=$($query.avg_cpu_s)",
                        "AvgLogicalReads=$($query.avg_logical_reads)",
                        "AvgLogicalWrites=$($query.avg_logical_writes)",
                        "QueryCategory='IO'",
                        "ExecutionPlanXML=$($query.QueryPlanXML)"
                    ) | Out-Null

                if ($query.avg_logical_reads -gt 1000) { # Threshold for alert
                    $script:alerts += "[$ServerName] Performance Alert: " + $alertMessage
                    Write-Log "[$ServerName] Performance Alert: " + $alertMessage "ALERT"
                    Insert-AlertToDB -ServerName $ServerName -AlertLevel "ALERT" -AlertCategory "Performance:HighIOQuery" -Message $alertMessage
                } else {
                    Write-Log "[$ServerName] INFO: I/O: Reads: $($query.avg_logical_reads), Writes: $($query.avg_logical_writes), Query: $queryPreview..." "INFO"
                }
            }
        } else {
            Write-Log "[$ServerName] INFO: No significant I/O consuming queries found." "INFO"
        }
    } catch {
        Write-Log "[$ServerName] ERROR: Failed to analyze I/O queries. Error: $($_.Exception.Message)" "ERROR"
